#include "Assets/Utilities - AstrophelMoore/Essentials/Systems/UnityAddons/Resources/ComputeShaderGeneric.cginc"
#include "Assets/Utilities - AstrophelMoore/Essentials/Systems/UnityAddons/Resources/ComputableMeshGeneric.cginc"
#include "Assets/Utilities - AstrophelMoore/Essentials/Systems/UnityAddons/Resources/ComputableMesh_Edges.cginc"

#pragma kernel CleanNullAreaTriangles

RWStructuredBuffer<uint> toClean;
float minArea;

bool IsNullAreaTriangle(float3 p0, float3 p1, float3 p2, float min)
{
    float area = length(cross(p1 - p0, p2 - p0)) * 0.5;
    return area < min;
}

[numthreads(128, 1, 1)]
void CleanNullAreaTriangles(uint id : SV_DispatchThreadID)
{
    if (id < indexCount)
    {
        int i = indexStart + (id * 3);

        float3 p0 = ExtractVertexPosition(ExtractIndex(i));
        float3 p1 = ExtractVertexPosition(ExtractIndex(i + 1));
        float3 p2 = ExtractVertexPosition(ExtractIndex(i + 2));

        if (IsNullAreaTriangle(p0, p1, p2, minArea))
            toClean[id] = 1.0;
        else 
            toClean[id] = 0.0;
    }
}

#pragma kernel ClearMask

RWStructuredBuffer<uint> mask;

[numthreads(128, 1, 1)]
void ClearMask(uint id : SV_DispatchThreadID)
{
    mask[id] = 0;
}

#pragma kernel FillMask

[numthreads(128, 1, 1)]
void FillMask(uint id : SV_DispatchThreadID)
{
    mask[id] = 1;
}

#pragma kernel GetSubmeshMask

[numthreads(128, 1, 1)]
void GetSubmeshMask(uint id : SV_DispatchThreadID)
{
    if (id < indexCount)
        mask[ExtractIndex(indexStart + id)] = 1;
}

//TO DO: Some functions are not being filtered by buffer size,
//that might be causing the issues on Lovecraftify.cs
#pragma kernel GetEdges

[numthreads(128, 1, 1)]
void GetEdges(uint id : SV_DispatchThreadID)
{
    if (id < indexCount)
    {
        int index = indexStart + (id * 3);
        edges[index].v1 = ExtractIndex(index);
        edges[index].v2 = ExtractIndex(index + 1);
        edges[index].index1 = index;
        edges[index].index2 = -1;
    
        edges[index + 1].v1 = ExtractIndex(index + 1);
        edges[index + 1].v2 = ExtractIndex(index + 2);
        edges[index + 1].index1 = index;
        edges[index + 1].index2 = -1;
    
        edges[index + 2].v1 = ExtractIndex(index + 2);
        edges[index + 2].v2 = ExtractIndex(index);
        edges[index + 2].index1 = index;
        edges[index + 2].index2 = -1;
    }
}

#pragma kernel ProccessDuplicateEdges

[numthreads(16, 16, 1)]
void ProccessDuplicateEdges(uint2 id : SV_DispatchThreadID)
{
    if (id.x < id.y)
        if (((edges[id.x].v1 == edges[id.y].v1) &&
            (edges[id.x].v2 == edges[id.y].v2))
            ||
            ((edges[id.x].v1 == edges[id.y].v2) &&
            (edges[id.x].v2 == edges[id.y].v1)))
        {
            // Duplicated edge triangle gets registered in the original edge
            edges[id.x].index2 = edges[id.y].index1;
            // Duplicated edge triangle's second value is marked as negative and
            // stores the codified value of original edge. Data is centralized in original edge.
            edges[id.y].index2 = -int(id.x) - 2;
        }
}