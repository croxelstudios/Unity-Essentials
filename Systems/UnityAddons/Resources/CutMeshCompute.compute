#include "Assets/Utilities - AstrophelMoore/Essentials/Systems/UnityAddons/Resources/ComputeShaderGeneric.cginc"
#include "Assets/Utilities - AstrophelMoore/Essentials/Systems/UnityAddons/Resources/ComputableMeshGeneric.cginc"

//TO DO: Some functions are not being filtered by buffer size,
//that might be causing the issues on Lovecraftify.cs
#pragma kernel GetEdges

struct Edge
{
    int v1;
    int v2;
    int index1;
    int index2;
};

RWStructuredBuffer<Edge> edges;

[numthreads(128, 1, 1)]
void GetEdges(uint id : SV_DispatchThreadID)
{
    if (id < indexCount)
    {
        int index = indexStart + (id * 3);
        edges[index].v1 = ExtractIndex(index);
        edges[index].v2 = ExtractIndex(index + 1);
        edges[index].index1 = index;
        edges[index].index2 = -1;
    
        edges[index + 1].v1 = ExtractIndex(index + 1);
        edges[index + 1].v2 = ExtractIndex(index + 2);
        edges[index + 1].index1 = index;
        edges[index + 1].index2 = -1;
    
        edges[index + 2].v1 = ExtractIndex(index + 2);
        edges[index + 2].v2 = ExtractIndex(index);
        edges[index + 2].index1 = index;
        edges[index + 2].index2 = -1;
    }
}

#pragma kernel ProccessDuplicateEdges

[numthreads(16, 16, 1)]
void ProccessDuplicateEdges(uint2 id : SV_DispatchThreadID)
{
    if (id.x < id.y)
        if (((edges[id.x].v1 == edges[id.y].v1) &&
            (edges[id.x].v2 == edges[id.y].v2))
            ||
            ((edges[id.x].v1 == edges[id.y].v2) &&
            (edges[id.x].v2 == edges[id.y].v1)))
        {
            edges[id.x].index2 = edges[id.y].index1;
            edges[id.y].index2 = -int(id.x) - 2;
        }
}

#pragma kernel GetIntersections

struct Intersection
{
    int info;
    uint leftIndex;
    VertexData vertex;
    VertexData extraVertex;
};

RWStructuredBuffer<Intersection> intersections;
float3 planeNormal;
float3 planePoint;

bool SegmentIntersectsPlane(float3 v1, float3 v2, float3 planePoint, float3 planeNormal)
{
    float dot1 = sign(dot(v1 - planePoint, planeNormal));
    float dot2 = sign(dot(v2 - planePoint, planeNormal));

    return dot1 != dot2;
}

float3 PlaneRaycast(float3 origin, float3 direction, float3 plp, float3 normal, out float dist)
{
    direction = normalize(direction);
    normal = normalize(normal);
    float plDist = dot(plp, -normal);
    dist = -(plDist + dot(origin, normal)) / dot(direction, normal);
    return origin + (direction * dist);
}

VertexData CalculateIntersectionVertexData(VertexData v1, VertexData v2,
    float3 planePoint, float3 planeNormal, out float dist)
{
    float3 direction = v2.position - v1.position;
    float3 pos = PlaneRaycast(v1.position, direction, planePoint, planeNormal, dist);
    float percent = length(pos - v2.position) / length(direction);

    float3 normal =
        normalize((v1.normal * percent) + 
        (v2.normal * (1.0 - percent)));

    float4 tangent =
        normalize((v1.tangent * percent) + 
        (v2.tangent * (1.0 - percent)));

    float4 color =
        (v1.color * percent) + 
        (v2.color * (1.0 - percent));

    float2 uv =
        (v1.uv * percent) + 
        (v2.uv * (1.0 - percent));

    VertexData data;
    data.position = pos;
    data.normal = normal;
    data.tangent = tangent;
    data.color = color;
    data.uv = uv;

    return data;
}

[numthreads(512, 1, 1)]
void GetIntersections(uint id : SV_DispatchThreadID)
{
    VertexData v1 = ExtractVertexData(edges[id].v1);
    VertexData v2 = ExtractVertexData(edges[id].v2);

    float dot1 = sign(dot(v1.position - planePoint, planeNormal));
    float dot2 = sign(dot(v2.position - planePoint, planeNormal));

    int i1 = id % 3;
    int i2 = (i1 == 2) ? 0 : i1 + 1;
    intersections[id].leftIndex = (dot1 < 0) ? i1 : i2;

    if (edges[id].index2 < -1)
        intersections[id].info = -edges[id].index2 - 2;
    else
    {
        if (dot1 != dot2)
        {
            intersections[id].info = -1;

            float dist;
            intersections[id].vertex =
                            CalculateIntersectionVertexData(v1, v2,
                                planePoint, planeNormal, dist);
        } 
        else intersections[id].info = -3;
    }
}

#pragma kernel GetTriangleCutData

struct TriangleCutProperties
{
    int triCount;
    int cutPoint1;
    int cutPoint2;
    int3 newTri1;
    int3 newTri2;
    int3 newTri3;
    int3 newTri4;
};

RWStructuredBuffer<TriangleCutProperties> cutsData;

void RegisterFullCutVertices(
    bool c12, bool c23, bool c31,
    uint i1, uint i2, uint i3, inout TriangleCutProperties prop)
{
    if (c12) prop.cutPoint1 = i1;
    else if (c31) prop.cutPoint1 = i3;
    if (c23) prop.cutPoint2 = i2;
    else if (c31) prop.cutPoint2 = i3;
}

void RegisterFullCutTriangles(uint index, bool c12, bool c23, bool c31, int leftIndex,
    inout TriangleCutProperties prop)
{
    uint ti1 = ExtractIndex(index);
    uint ti2 = ExtractIndex(index + 1);
    uint ti3 = ExtractIndex(index + 2);
    
    bool isToLeft;
    if (!c12)
    {
        isToLeft = leftIndex == 2;
        prop.newTri1 = int3(ti3, isToLeft ? -2 : -1, isToLeft ? -4 : -3);
        prop.newTri2 = int3(isToLeft ? -1 : -2, ti1, isToLeft ? -3 : -4);
        prop.newTri3 = int3(ti1, ti2, isToLeft ? -3 : -4);
    }
    else if (!c23)
    {
        isToLeft = leftIndex == 0;
        prop.newTri1 = int3(ti1, isToLeft ? -2 : -1, isToLeft ? -4 : -3);
        prop.newTri2 = int3(isToLeft ? -1 : -2, ti2, isToLeft ? -3 : -4);
        prop.newTri3 = int3(ti2, ti3, isToLeft ? -3 : -4);
    }
    else
    {
        isToLeft = leftIndex == 1;
        prop.newTri1 = int3(ti2, isToLeft ? -4 : -3, isToLeft ? -2 : -1);
        prop.newTri2 = int3(isToLeft ? -3 : -4, ti3, isToLeft ? -1 : -2);
        prop.newTri3 = int3(ti3, ti1, isToLeft ? -1 : -2);
    }
}

[numthreads(128, 1, 1)]
void GetTriangleCutData(uint id : SV_DispatchThreadID)
{
    if (id < indexCount)
    {
        uint index = indexStart + (id * 3);

        uint i1 = index;
        uint i2 = index + 1;
        uint i3 = index + 2;

        //Process intersection info
        i1 = (intersections[i1].info > 0) ? intersections[i1].info : i1;
        i2 = (intersections[i2].info > 0) ? intersections[i2].info : i2;
        i3 = (intersections[i3].info > 0) ? intersections[i3].info : i3;

        bool c12 = (intersections[i1].info == -1);
        bool c23 = (intersections[i2].info == -1);
        bool c31 = (intersections[i3].info == -1);

        if (c12 || c23 || c31)
        {
            RegisterFullCutVertices(c12, c23, c31, i1, i2, i3, cutsData[id]);

            int leftIndex;
            if (c12) leftIndex = intersections[index].leftIndex;
            else leftIndex = intersections[index + 1].leftIndex;

            RegisterFullCutTriangles(index, c12, c23, c31, leftIndex, cutsData[id]);
        
            cutsData[id].triCount = 3;
        }
        else cutsData[id].triCount = 1;
    }
}

#pragma kernel GetTriangleCutData_SquareCut

float3 upDirection;
float size;

void RegisterExtraCutTriangle(uint index, bool c12, bool c23, bool c31,
    bool v1IsValid, inout TriangleCutProperties prop)
{
    uint ti1 = ExtractIndex(index);
    uint ti2 = ExtractIndex(index + 1);
    uint ti3 = ExtractIndex(index + 2);

    int3 p;
    if (v1IsValid)
    {
        p = prop.newTri1;
        prop.newTri1 = int3(
            p.x == -4 ? -3 : p.x,
            p.y == -4 ? -3 : p.y,
            p.z == -4 ? -3 : p.z);
        p = prop.newTri2;
        prop.newTri2 = int3(
            p.x == -4 ? -3 : p.x,
            p.y == -4 ? -3 : p.y,
            p.z == -4 ? -3 : p.z);
        p = prop.newTri3;
        prop.newTri3 = int3(
            p.x == -4 ? -3 : p.x,
            p.y == -4 ? -3 : p.y,
            p.z == -4 ? -3 : p.z);

        if (!c12) prop.newTri4 = int3(ti3, -3, ti2);
        else if (!c23) prop.newTri4 = int3(ti1, -3, ti3);
        else prop.newTri4 = int3(ti2, ti3, -3);
    }
    else
    {
        p = prop.newTri1;
        prop.newTri1 = int3(
            p.x == -2 ? -1 : p.x,
            p.y == -2 ? -1 : p.y,
            p.z == -2 ? -1 : p.z);
        p = prop.newTri2;
        prop.newTri2 = int3(
            p.x == -2 ? -1 : p.x,
            p.y == -2 ? -1 : p.y,
            p.z == -2 ? -1 : p.z);
        p = prop.newTri3;
        prop.newTri3 = int3(
            p.x == -2 ? -1 : p.x,
            p.y == -2 ? -1 : p.y,
            p.z == -2 ? -1 : p.z);

        if (!c12) prop.newTri4 = int3(ti3, ti1, -1);
        else if (!c23) prop.newTri4 = int3(ti1, ti2, -1);
        else prop.newTri4 = int3(ti2, -1, ti1);
    }
}

[numthreads(128, 1, 1)]
void GetTriangleCutData_SquareCut(uint id : SV_DispatchThreadID)
{
    if (id < indexCount)
    {
        uint index = indexStart + (id * 3);

        uint oi1 = index;
        uint oi2 = index + 1;
        uint oi3 = index + 2;

        //Process intersection info
        uint i1 = (intersections[oi1].info > 0) ? intersections[oi1].info : oi1;
        uint i2 = (intersections[oi2].info > 0) ? intersections[oi2].info : oi2;
        uint i3 = (intersections[oi3].info > 0) ? intersections[oi3].info : oi3;

        if (cutsData[id].triCount > 1)
        {
            uint ti1 = ExtractIndex(oi1);
            uint ti2 = ExtractIndex(oi2);
            uint ti3 = ExtractIndex(oi3);
            bool c12, c23, c31;
            c12 = c23 = c31 = false;
            if (cutsData[id].newTri1.x == (int)ti3) c23 = c31 = true;
            else if (cutsData[id].newTri1.x == (int)ti1) c12 = c31 = true;
            else c12 = c23 = true;

            uint oPoint1;
            uint oPoint2;
            if (c12) oPoint1 = oi1;
            else oPoint1 = oi3;
            if (c23) oPoint2 = oi2;
            else oPoint2 = oi3;

            VertexData v1 = intersections[cutsData[id].cutPoint1].vertex;
            VertexData v2 = intersections[cutsData[id].cutPoint2].vertex;

            float3 crossP = cross(upDirection, planeNormal);
            float3 topP = planePoint + upDirection * size;
            float3 bottomP = planePoint - upDirection * size;
            float3 rightP = planePoint + crossP * size;
            float3 leftP = planePoint - crossP * size;
        
            if ((SegmentIntersectsPlane(v1.position, planePoint, topP, upDirection) ||
                SegmentIntersectsPlane(v1.position, planePoint, bottomP, upDirection) ||
                SegmentIntersectsPlane(v1.position, planePoint, rightP, crossP) ||
                SegmentIntersectsPlane(v1.position, planePoint, leftP, crossP)) &&
                (SegmentIntersectsPlane(v2.position, planePoint, topP, upDirection) ||
                SegmentIntersectsPlane(v2.position, planePoint, bottomP, upDirection) ||
                SegmentIntersectsPlane(v2.position, planePoint, rightP, crossP) ||
                SegmentIntersectsPlane(v2.position, planePoint, leftP, crossP)))
            {
                intersections[oi1].info = -3;
                intersections[oi2].info = -3;
                intersections[oi3].info = -3;
                cutsData[id].triCount = 0;
            }
            else
            {
                bool top = SegmentIntersectsPlane(v1.position, v2.position, topP, upDirection);
                bool bottom = SegmentIntersectsPlane(v1.position, v2.position, bottomP, upDirection);
                bool right = SegmentIntersectsPlane(v1.position, v2.position, rightP, crossP);
                bool left = SegmentIntersectsPlane(v1.position, v2.position, leftP, crossP);
                float sum = (float)top + (float)bottom + (float)right + (float)left;

                switch (sum)
                {
                    default:
                        break;
                    case 2:
                        intersections[oi1].info = -3;
                        intersections[oi2].info = -3;
                        intersections[oi3].info = -3;
                        cutsData[id].triCount = -1;
                        break;
                    case 1:
                        float3 plp;
                        if (top) plp = topP;
                        else if (bottom) plp = bottomP;
                        else if (right) plp = rightP;
                        else plp = leftP;

                        float3 n;
                        if (top || bottom) n = upDirection;
                        else n = crossP;

                        bool v1IsValid = !SegmentIntersectsPlane(v1.position, planePoint, plp, n);

                        float dist;
                        VertexData vertex = CalculateIntersectionVertexData(v1, v2, plp, n, dist);
                
                        if (v1IsValid)
                        {
                            cutsData[id].cutPoint2 = oPoint2;
                            intersections[oPoint2].info = -2;
                            intersections[oPoint2].extraVertex = vertex;
                        }
                        else
                        {
                            cutsData[id].cutPoint1 = oPoint1;
                            intersections[oPoint1].info = -2;
                            intersections[oPoint1].extraVertex = vertex;
                        }
                
                        RegisterExtraCutTriangle(index, c12, c23, c31, v1IsValid, cutsData[id]);
                
                        cutsData[id].triCount = 4;
                        break;
                }
            }
        }
    }
}

#pragma kernel CleanNullAreaTrianglesInIntersection

float minArea;

float3 InterpretTriValue(float3 cutPoint1, float3 cutPoint2, int value)
{
    switch (value)
    {
        case -1:
            return cutPoint1;
        case -2:
            return cutPoint1;
        case -3:
            return cutPoint2;
        case -4:
            return cutPoint2;
        default:
            return ExtractVertexPosition(value);
    }
}

bool IsNullAreaTriangle(float3 p0, float3 p1, float3 p2, float min)
{
    float area = length(cross(p1 - p0, p2 - p0)) * 0.5;
    return area < min;
}

bool IsNullAreaTriangle(float3 point1, float3 point2, int3 tri, float min)
{
    float3 p0 = InterpretTriValue(point1, point2, tri.x);
    float3 p1 = InterpretTriValue(point1, point2, tri.y);
    float3 p2 = InterpretTriValue(point1, point2, tri.z);

    return IsNullAreaTriangle(p0, p1, p2, min);
}

[numthreads(128, 1, 1)]
void CleanNullAreaTrianglesInIntersection(uint id : SV_DispatchThreadID)
{
    Intersection inter1 = intersections[cutsData[id].cutPoint1];
    Intersection inter2 = intersections[cutsData[id].cutPoint2];
    float3 point1 = (inter1.info < -1) ? inter1.extraVertex.position : inter1.vertex.position;
    float3 point2 = (inter2.info < -1) ? inter2.extraVertex.position : inter2.vertex.position;

    if (IsNullAreaTriangle(point1, point2, cutsData[id].newTri1, minArea))
        cutsData[id].newTri1 = float3(-5, -5, -5);
    if (IsNullAreaTriangle(point1, point2, cutsData[id].newTri2, minArea))
        cutsData[id].newTri2 = float3(-5, -5, -5);
    if (IsNullAreaTriangle(point1, point2, cutsData[id].newTri3, minArea))
        cutsData[id].newTri3 = float3(-5, -5, -5);
    if (IsNullAreaTriangle(point1, point2, cutsData[id].newTri4, minArea))
        cutsData[id].newTri4 = float3(-5, -5, -5);
}